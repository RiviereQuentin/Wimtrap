readPSFM <- function (file_path)
{
  list_pfm <- list()
  readRaw <- suppressWarnings(readLines(file(file_path)))
  MotifIDLines <- which(regexpr("^>", readRaw) >= 1)
  for (i in seq_along(MotifIDLines)) {
    MotifID <- unlist(strsplit(readRaw[MotifIDLines[i]],
                               ">"))[2]
    MotifID <- unlist(strsplit(MotifID, "\\s+"))[[1]]
    A_frequencies <- unlist(strsplit(readRaw[MotifIDLines[i] +
                                               1], "\\s+"))
    A_frequencies <- suppressWarnings(as.numeric(A_frequencies))
    A_frequencies <- A_frequencies[!(is.na(A_frequencies))]
    Frequencies <- matrix(A_frequencies, nrow = 1)
    for (j in seq(2, 4)) {
      X_frequencies <- unlist(strsplit(readRaw[MotifIDLines[i] +
                                                 j], "\\s+"))
      X_frequencies <- suppressWarnings(as.numeric(X_frequencies))
      X_frequencies <- X_frequencies[!(is.na(X_frequencies))]
      Frequencies <- rbind(Frequencies, X_frequencies)
    }
    rownames(Frequencies) <- NULL
    list_pfm[[i]] <- Frequencies
    rownames(list_pfm[[i]]) <- c("A", "C", "G", "T")
    names(list_pfm)[i] <- MotifID
  }
  return(list_pfm)
}
buildPwm <- function (pfm, genome)
{
  NbChromosomes <- length(genome)
  if (Biostrings::width(genome)[1] > 2e+06) {
    Start <- stats::runif(1000, 1, Biostrings::width(genome)[1] -
                            2000)
    SequencesSample <- Biostrings::Views(genome[[1]], start = Start,
                                         end = Start + 2000)
    NucleotideComp <- apply(Biostrings::letterFrequency(SequencesSample,
                                                        c("A", "C", "G", "T")), 2, mean)/2000
  }
  else {
    NucleotideComp <- Biostrings::letterFrequency(genome[[1]],
                                                  c("A", "C", "G", "T"))/length(genome[[1]])
  }
  for (i in seq(2, NbChromosomes)) {
    if (Biostrings::width(genome)[i] > 2e+06) {
      Start <- stats::runif(1000, 1, Biostrings::width(genome)[i] -
                              2000)
      SequencesSample <- Biostrings::Views(genome[[i]],
                                           start = Start, end = Start + 2000)
      NucleotideComp <- (NucleotideComp + apply(Biostrings::letterFrequency(SequencesSample,
                                                                            c("A", "C", "G", "T")), 2, mean)/2000)/2
    }
    else {
      NucleotideComp <- (NucleotideComp + Biostrings::letterFrequency(genome[[i]],
                                                                      c("A", "C", "G", "T"))/length(genome[[i]]))/2
    }
  }
  NucleotideComp <- round(NucleotideComp, 3)
  TotalCounts <- apply(pfm, 2, sum)
  b <- rep(sqrt(TotalCounts), 4)
  pwm <- (pfm + NucleotideComp * b)/(TotalCounts + b)
  return(pwm)
}
#________________________________________________________________________________________#
#HIDDEN FUNCTION
#========================================================================================#
### Returns a list of matrices describing the Pwm of each considered TF.
### The PWM might be directly input as a matrix or imported from a source
### file encoded in jaspar.
### If the organism is Arabidopsis thaliana, the PWM can be automatically
### searched in the PlanTFDB database
#========================================================================================#
getPwm <- function(pfm_path, TFnames = NULL, genome){
    List_pfm <- wimtrap:::readPSFM(pfm_path)
    Pwm <- list()
    for (i in seq_along(List_pfm)) {
      Pwm[[i]] <- wimtrap:::buildPwm(List_pfm[[i]], genome)
      names(Pwm)[[i]] <- names(List_pfm)[i]
      rownames(Pwm[[i]]) <- c("A", "C", "G", "T")
    }
    if (length(TFnames) > 0 ){
      Pwm <- Pwm[names(Pwm) %in% TFnames]
    }
  return(Pwm)
}
#________________________________________________________________________________________#
#HIDDEN FUNCTION
#========================================================================================#
### Implements a fast method of pattern-matching
#========================================================================================#
matrixScan <- function (pwm, genome, pvalThreshold = 0.001, GRanges = NULL){
  NbChromosomes <- length(genome)
  Start <- runif(200, 1, Biostrings::width(genome)[1] - 5000)
  Start <- Start[!(is.na(Start))]
  SequencesSample <- Biostrings::Views(genome[[1]], start = Start,
                                       end = Start + 5000)
  SequencesSample <- list(SequencesSample)
  if (NbChromosomes > 1) {
    for (i in seq(2, NbChromosomes)) {
      Start <- runif(200, 1, Biostrings::width(genome)[i] -
                       5000)
      Start <- Start[!(is.na(Start))]
      SequencesSample[[i]] <- Biostrings::Views(genome[[i]],
                                                start = Start, end = Start + 5000)
    }
  }
  RandomFwScan <- lapply(SequencesSample, Biostrings::matchPWM,
                         pwm = pwm, min.score = "0%", with.score = TRUE)
  RandomRwScan <- lapply(SequencesSample, Biostrings::matchPWM,
                         pwm = Biostrings::reverseComplement(pwm), min.score = "0%",
                         with.score = TRUE)
  RandomScores <- rtracklayer::mcols(RandomFwScan[[1]])
  if (length(genome) == 1) {
    init = 1
  } else {
    init = 2
  }
  for (i in seq(init, length(genome))) {
    RandomScores <- rbind(RandomScores, rtracklayer::mcols(RandomFwScan[[i]]))
  }
  for (i in seq_along(genome)) {
    RandomScores <- rbind(RandomScores, rtracklayer::mcols(RandomRwScan[[i]]))
  }
  RandomScores <- RandomScores@listData$score
  DistributionScores <- graphics::hist(RandomScores, breaks = 1e+06,
                                       plot = FALSE)
  PvaluesScores <- cumsum(DistributionScores$counts[seq(length(DistributionScores$counts),
                                                        1, -1)])/sum(DistributionScores$counts)
  PvaluesCentered <- abs(PvaluesScores - pvalThreshold)
  ScoreThreshold <- DistributionScores$breaks[length(DistributionScores$breaks) -
                                                which.min(PvaluesCentered) + 1]
  if (length(GRanges) == 0){
    ScanFw <- lapply(genome, Biostrings::matchPWM, pwm = pwm,
                     min.score = ScoreThreshold, with.score = TRUE)
    ScanRw <- lapply(genome, Biostrings::matchPWM, pwm = Biostrings::reverseComplement(pwm),
                     min.score = ScoreThreshold, with.score = TRUE)
    NbMatchesFw <- unlist(lapply(ScanFw, length))
    NbMatchesRw <- unlist(lapply(ScanRw, length))
    seqnamesMatches <- S4Vectors::Rle(rep(names(ScanFw), 2),
                                      c(NbMatchesFw, NbMatchesRw))
    rangesMatches <- IRanges::IRanges(ScanFw[[1]]@ranges)
    if (length(genome) > 1) {
      for (i in seq(2, length(ScanFw))) {
        rangesMatches <- c(rangesMatches, IRanges::IRanges(ScanFw[[i]]@ranges))
      }
    }
    for (i in seq_along(ScanRw)) {
      rangesMatches <- c(rangesMatches, IRanges::IRanges(ScanRw[[i]]@ranges))
    }
    strandMatches <- S4Vectors::Rle(c("+", "-"), c(sum(NbMatchesFw),
                                                   sum(NbMatchesRw)))
    scoreMatches <- rtracklayer::mcols(ScanFw[[1]])
    if (length(genome) > 1) {
      for (i in seq(2, length(ScanFw))) {
        scoreMatches <- rbind(scoreMatches, rtracklayer::mcols(ScanFw[[i]]))
      }
    }
    for (i in seq_along(ScanRw)) {
      scoreMatches <- rbind(scoreMatches, rtracklayer::mcols(ScanRw[[i]]))
    }
    names(scoreMatches) <- "matchScore"
    x <- c(round(min(scoreMatches[, 1]), 5), round(RandomScores,
                                                   5), round(max(scoreMatches[, 1]), 5))
    if (length(which(is.infinite(x)))) {
      x <- x[-which(is.infinite(x))]
    }
    DistributionScores <- graphics::hist(x, breaks = c(0, seq(min(x,
                                                                  na.rm = TRUE), max(x, na.rm = TRUE) + pvalThreshold/10,
                                                              pvalThreshold/100)), ylim = c(0, length(x)), plot = FALSE)
    PvaluesScores <- cumsum(DistributionScores$counts[seq(length(DistributionScores$counts),
                                                          1, -1)])/sum(DistributionScores$counts)
    regionMatches <- NULL
  } else {
    GenomeInfoDb::seqlevels(GRanges) <- getRiddChr(GenomeInfoDb::seqlevels(GRanges))
    chromosomes <- GenomeInfoDb::seqlevels(GRanges)
    if (length(GenomicRanges::mcols(GRanges)$name) == 0){
      GenomicRanges::mcols(GRanges)$name <- as.character(seq(1, length(GRanges)))
    }
    pattern_analysis <- list()
    for (chromosome in chromosomes){
      DNAsequences <- Biostrings::Views(genome[[chromosome]],
                                        start = GenomicRanges::start(GRanges[GenomicRanges::seqnames(GRanges) == chromosome]),
                                        end = GenomicRanges::end(GRanges[GenomicRanges::seqnames(GRanges) == chromosome]))
      ScanFw <- lapply(DNAsequences, Biostrings::matchPWM, pwm = pwm,
                       min.score = ScoreThreshold, with.score = TRUE)
      if (length(ScanFw) > 0){
      NbMatchesByRegion <- unlist(lapply(ScanFw, length))
      RegionsLabel <- as.character(S4Vectors::Rle(GenomicRanges::mcols(GRanges[GenomicRanges::seqnames(GRanges) == chromosome])$name,
                                     NbMatchesByRegion))
      StartsLabel <- as.integer(S4Vectors::Rle(GenomicRanges::start(GRanges[GenomicRanges::seqnames(GRanges) == chromosome]),
                                     NbMatchesByRegion))
      EndsLabel <- as.integer(S4Vectors::Rle(GenomicRanges::end(GRanges[GenomicRanges::seqnames(GRanges) == chromosome]),
                                     NbMatchesByRegion))
      ScanFw <- lapply(ScanFw, function(region){
        scores <- region@elementMetadata
        if (nrow(scores) > 0){
          region <- data.frame(
            seqname = chromosome,
            as.data.frame(region@ranges),
            strand = "+",
            score = scores,
            Region = "a",
            startRegion = 0
            )
          } else {
            region <- data.frame(
              seqname = chromosome,
              start = 0,
              end = 0,
              width = 0,
              strand = "+",
              score = 0,
              Region = "a",
              startRegion = 0
            )
        }
        return(region)
      })
      ScanFw <- do.call(rbind, ScanFw)
      ScanFw <- ScanFw[ScanFw$score > 0,]
      ScanFw$Region <- RegionsLabel
      ScanFw$startRegion <- StartsLabel
      ScanFw$start <- (ScanFw$start-1) + ScanFw$startRegion
      ScanFw$end <- (ScanFw$end-1) + ScanFw$startRegion
      ScanFw <- ScanFw[,-8]
      }
      ScanRw <- lapply(DNAsequences, Biostrings::matchPWM, pwm = Biostrings::reverseComplement(pwm),
                       min.score = ScoreThreshold, with.score = TRUE)
      if (length(ScanRw) > 0){
      NbMatchesByRegion <- unlist(lapply(ScanRw, length))
      RegionsLabel <- as.character(S4Vectors::Rle(GenomicRanges::mcols(GRanges[GenomicRanges::seqnames(GRanges) == chromosome])$name,
                                                  NbMatchesByRegion))
      StartsLabel <- as.integer(S4Vectors::Rle(GenomicRanges::start(GRanges[GenomicRanges::seqnames(GRanges) == chromosome]),
                                               NbMatchesByRegion))
      EndsLabel <- as.integer(S4Vectors::Rle(GenomicRanges::end(GRanges[GenomicRanges::seqnames(GRanges) == chromosome]),
                                             NbMatchesByRegion))
      ScanRw <- lapply(ScanRw, function(region){
        scores <- region@elementMetadata
        if (nrow(scores) > 0){
          region <- data.frame(
            seqname = chromosome,
            as.data.frame(region@ranges),
            strand = "-",
            score = scores,
            Region = "a",
            startRegion = 0
          )
        } else {
          region <- data.frame(
            seqname = chromosome,
            start = 0,
            end = 0,
            width = 0,
            strand = "-",
            score = 0,
            Region = "a",
            startRegion = 0
          )
        }
        return(region)
      })
      ScanRw <- do.call(rbind, ScanRw)
      ScanRw <- ScanRw[ScanRw$score > 0,]
      ScanRw$Region <- RegionsLabel
      ScanRw$startRegion <- StartsLabel
      ScanRw$start <- (ScanRw$start-1) + ScanRw$startRegion
      ScanRw$end <- (ScanRw$end-1) + ScanRw$startRegion
      ScanRw <- ScanRw[,-8]
      }
      if (length(ScanFw) > 0 & length(ScanRw) > 0){
        pattern_analysis[[chromosome]] <- rbind(ScanFw, ScanRw)
      } else {
        if (length(ScanFw) > 0){
          pattern_analysis[[chromosome]] <- ScanFw
        } else {
          if (length(ScanRw) > 0)
            pattern_analysis[[chromosome]] <- ScanRw
        }
      }

    }
    ScanTrack <- do.call(rbind, pattern_analysis)
    seqnamesMatches <- ScanTrack$seqname
    scoreMatches <- as.data.frame(ScanTrack$score)
    colnames(scoreMatches) <- "matchScore"
    rangesMatches <- IRanges::IRanges(start = ScanTrack$start,
                                      end = ScanTrack$end)
    strandMatches <- ScanTrack$strand
    regionMatches <- ScanTrack$Region
  }
  PvaluesTable <- data.frame(score = DistributionScores$breaks[2:(length(DistributionScores$breaks) -
                                                                    1)], p.value = PvaluesScores[seq((length(PvaluesScores) -
                                                                                                        1), 1, -1)])
  PvaluesTable <- rbind(PvaluesTable, c(round(max(scoreMatches[,
                                                               1]), 4), 0))
  scores <- as.factor(round(scoreMatches[, 1], 4))
  PvaluesTable <- PvaluesTable[PvaluesTable$score %in% scores,
                               ]
  levels(scores) <- PvaluesTable$p.value
  matchLogPval <- log10(as.numeric(as.character(scores)))
  matchLogPval[is.infinite(matchLogPval)] <- min(matchLogPval[!(is.infinite(matchLogPval))])
  if (length(regionMatches) > 0) {
    ScanTrack <- GenomicRanges::GRanges(seqnames = seqnamesMatches,
                                        ranges = rangesMatches, strand = strandMatches, scoreMatches,
                                        matchLogPval, region = regionMatches)
  } else {
    ScanTrack <- GenomicRanges::GRanges(seqnames = seqnamesMatches,
                                      ranges = rangesMatches, strand = strandMatches, scoreMatches,
                                      matchLogPval)
    }
  overlaps <- GenomicRanges::findOverlaps(ScanTrack[GenomicRanges::strand(ScanTrack) == "+"], ScanTrack[GenomicRanges::strand(ScanTrack) == "-"],
                                          ignore.strand = TRUE)
  ScanTrack <- ScanTrack[-(length(ScanTrack[GenomicRanges::strand(ScanTrack) == "+"])+overlaps@to)]
  return(ScanTrack)
}
getRiddChr <- function (names)
{
  Character <- is.character(names)
  names <- base::tolower(names)
  names <- factor(names)
  regChr <- regexpr("^chr", levels(names))
  if (length(which(regChr > 0))) {
    NewNames <- c()
    for (i in which(regChr > 0)) {
      NewNames <- c(NewNames, unlist(strsplit(levels(names)[[i]],
                                              "chr"))[2])
    }
    levels(names)[which(regChr > 0)] <- NewNames
  }
  else {
  }
  if (Character) {
    names <- as.character(names)
  }
  return(names)
}
importFeatures <- function (file_paths)
{
  feature_GRanges_list <- list()
  for (i in seq_along(file_paths)) {
    BEDorGFF <- unlist(strsplit(file_paths[i], "[.]"))[length(strsplit(file_paths[i],
                                                                       "[.]")[[1]])]
    if (BEDorGFF == "bed") {
      BEDorGFF <- 5
    }
    else {
      if (BEDorGFF == "gff") {
        BEDorGFF <- 6
      }
      else {
      }
    }
    if (is.numeric(BEDorGFF)) {
      NumOrCat_Data <- utils::read.csv(file_paths[[i]],
                                       sep = "\t")
      if (BEDorGFF == 5) {
        if (length(NumOrCat_Data) > 4) {
          if (is.factor(NumOrCat_Data[, BEDorGFF])) {
            if (length(NumOrCat_Data) > 5) {
              Strands = NumOrCat_Data[, 6]
            }
            else {
              Strands = rep("*", dim(NumOrCat_Data)[1])
            }
            feature_GRanges <- data.frame(seqnames = NumOrCat_Data[,
                                                                   1], start = NumOrCat_Data[, 2], end = NumOrCat_Data[,
                                                                                                                       3], strand = Strands, score = as.character(NumOrCat_Data[,
                                                                                                                                                                                5]))
          }
          else {
            feature_GRanges <- as.data.frame(rtracklayer::import(file_paths[i]))
          }
        }
        else {
          feature_GRanges <- as.data.frame(rtracklayer::import(file_paths[i]))
        }
      }
      else {
        if (length(NumOrCat_Data) > 5) {
          if (is.factor(NumOrCat_Data[, BEDorGFF])) {
            if (length(NumOrCat_Data) > 6) {
              Strands = NumOrCat_Data[, 7]
            }
            else {
              Strands = rep("*", dim(NumOrCat_Data)[1])
            }
            feature_GRanges <- data.frame(seqnames = NumOrCat_Data[,
                                                                   1], start = NumOrCat_Data[, 4], end = NumOrCat_Data[,
                                                                                                                       5], strand = Strands, score = as.character(NumOrCat_Data[,
                                                                                                                                                                                6]))
          }
          else {
            feature_GRanges <- as.data.frame(rtracklayer::import(file_paths[i]))
          }
        }
        else {
          feature_GRanges <- as.data.frame(rtracklayer::import(file_paths[i]))
        }
      }
    }
    else {
      feature_GRanges <- as.data.frame(rtracklayer::import(file_paths[i]))
    }
    if (is.null(feature_GRanges$score)) {
      feature_GRanges <- data.frame(seqnames = feature_GRanges$seqnames,
                                    start = feature_GRanges$start, end = feature_GRanges$end,
                                    strand = feature_GRanges$strand)
    }
    else {
      feature_GRanges <- data.frame(seqnames = feature_GRanges$seqnames,
                                    start = feature_GRanges$start, end = feature_GRanges$end,
                                    strand = feature_GRanges$strand, score = feature_GRanges$score)
    }
    feature_GRanges$seqnames <- getRiddChr(feature_GRanges$seqnames)
    FeatureName <- strsplit(file_paths[i], "/")[[1]]
    FeatureName <- FeatureName[length(FeatureName)]
    FeatureName <- strsplit(FeatureName, "[.]")[[1]][1]
    FeatureName <- FeatureName[length(FeatureName)]
    if (!(is.null(feature_GRanges$score))) {
      colnames(feature_GRanges)[5] <- FeatureName
    }
    feature_GRanges <- GenomicRanges::makeGRangesFromDataFrame(feature_GRanges,
                                                               keep.extra.columns = TRUE)
    feature_GRanges_list[[i]] <- feature_GRanges
    names(feature_GRanges_list)[[i]] <- FeatureName
  }
  return(feature_GRanges_list)
}


#________________________________________________________________________________________#
#HIDDEN FUNCTION
#========================================================================================#
### Lists for each TF as GRanges object the location of their ChIP-peaks,
### which is input by user as GRanges objects or from BED source file(s)
### The regions defining the ChIP-peaks are limited to a fixed lenght
### anchored to the center
#========================================================================================#
listChIPRegions <- function(ChIP_paths, width)
{
  #@Import regions from BED files
  ChIP_regions <- lapply(ChIP_paths, read.delim, header = FALSE)
  #Limit the length of the ChIP-peaks to
  #400bp around the center
  for (i in 1:length(ChIP_regions)){
    considered <- ChIP_regions[[i]]
    considered <- data.frame(
      seqnames = considered[,1],
      start = considered[,2],
      end = considered[,3]
    )
    considered$seqnames <- getRiddChr(considered$seqnames)
    considered <- GenomicRanges::makeGRangesFromDataFrame(considered)
    considered <- IRanges::resize(considered, width, fix = "center")
    ChIP_regions[[i]] <- considered
  }
  names(ChIP_regions) <- names(ChIP_paths)
  ChIP_regions <- c(ChIP_regions)
  return(ChIP_regions)
}
#________________________________________________________________________________________#
#HIDDEN FUNCTION
#========================================================================================#
### Allows to determine the transcript whose the TSS (TTS) is the closest to PWM matches
### and to calculte the distance to its TSS (TTS)
#========================================================================================#
getClosest <- function(GRanges_data, StructureTracks, modeling = TRUE,
                       strandAsFeature = FALSE,
                       TSS = TRUE){
  #Distance to TSS or TTS?
  if (TSS == TRUE){
    TSS_Track <- StructureTracks[[length(StructureTracks)]]
  } else {
    TSS_Track <- StructureTracks[[length(StructureTracks) - 1]]
  }
  GRanges_data <- GRanges_data[as.character(GenomicRanges::seqnames(GRanges_data)) %in%
                                 as.character(GenomeInfoDb::seqlevels(TSS_Track))]
  ClosestTSS_Indices <- GenomicRanges::nearest(GRanges_data,
                                               TSS_Track, ignore.strand = TRUE)
  ClosestTSS_Data <- TSS_Track[ClosestTSS_Indices, ]
  ClosestTSS <- rtracklayer::mcols(TSS_Track)[ClosestTSS_Indices,
                                              1]
  DistToClosestTSS <- GenomicRanges::distanceToNearest(GRanges_data,
                                                       TSS_Track, ignore.strand = TRUE)
  DistToClosestTSS <- rtracklayer::mcols(DistToClosestTSS)[,
                                                           1]
  DistToClosestTSS[as.logical((GenomicRanges::start(ClosestTSS_Data) >
                                 GenomicRanges::start(GRanges_data)) & (GenomicRanges::strand(ClosestTSS_Data) ==
                                                                          "+"))] <- -DistToClosestTSS[as.logical((GenomicRanges::start(ClosestTSS_Data) >
                                                                                                                    GenomicRanges::start(GRanges_data)) & (GenomicRanges::strand(ClosestTSS_Data) ==
                                                                                                                                                             "+"))]
  DistToClosestTSS[as.logical((GenomicRanges::start(ClosestTSS_Data) <
                                 GenomicRanges::start(GRanges_data)) & (GenomicRanges::strand(ClosestTSS_Data) ==
                                                                          "-"))] <- -DistToClosestTSS[as.logical((GenomicRanges::start(ClosestTSS_Data) <
                                                                                                                    GenomicRanges::start(GRanges_data)) & (GenomicRanges::strand(ClosestTSS_Data) ==
                                                                                                                                                             "-"))]
  if (TSS ==  TRUE){
    if (strandAsFeature) {
      if (modeling) {
        MetaData <- cbind(as.data.frame(GenomicRanges::mcols(GRanges_data)),
                          DistToClosestTSS = DistToClosestTSS, TranscriptOrientation = as.character(GenomicRanges::strand(ClosestTSS_Data)))
      }
      else {
        MetaData <- cbind(as.data.frame(GenomicRanges::mcols(GRanges_data)),
                          ClosestTSS = ClosestTSS, DistToClosestTSS = DistToClosestTSS,
                          TranscriptOrientation = as.character(GenomicRanges::strand(ClosestTSS_Data)))
      }
    } else {
      if (modeling) {
        MetaData <- cbind(as.data.frame(GenomicRanges::mcols(GRanges_data)),
                          DistToClosestTSS = DistToClosestTSS)
      }
      else {
        MetaData <- cbind(as.data.frame(GenomicRanges::mcols(GRanges_data)),
                          ClosestTSS = ClosestTSS, DistToClosestTSS = DistToClosestTSS)
      }
    }
  }
  else {
    if (strandAsFeature) {
      if (modeling) {
        MetaData <- cbind(as.data.frame(GenomicRanges::mcols(GRanges_data)),
                          DistToClosestTTS = DistToClosestTSS, TranscriptOrientation = as.character(GenomicRanges::strand(ClosestTSS_Data)))
      }
      else {
        MetaData <- cbind(as.data.frame(GenomicRanges::mcols(GRanges_data)),
                          ClosestTTS = ClosestTSS, DistToClosestTTS = DistToClosestTSS,
                          TranscriptOrientation = as.character(GenomicRanges::strand(ClosestTSS_Data)))
      }
    } else {
      if (modeling) {
        MetaData <- cbind(as.data.frame(GenomicRanges::mcols(GRanges_data)),
                          DistToClosestTTS = DistToClosestTSS)
      }
      else {
        MetaData <- cbind(as.data.frame(GenomicRanges::mcols(GRanges_data)),
                          ClosestTTS = ClosestTSS, DistToClosestTTS = DistToClosestTSS)
      }
    }
  }
  GRanges_data <- GenomicRanges::GRanges(seqnames = GenomeInfoDb::seqnames(GRanges_data),
                                         ranges = IRanges::IRanges(start = GenomicRanges::start(GRanges_data),
                                                                   end = GenomicRanges::end(GRanges_data)), strand = GenomicRanges::strand(GRanges_data),
                                         MetaData)
  return(GRanges_data)
}

#________________________________________________________________________________________#
#Exported function
#========================================================================================#
### Allows to get the source genomic annotations used to contextualize PWM matches.
### Outputs a list of GRanges objects corresponding to the genomic regions and annotations
### described in BED files whose local paths on the computer is specified throught the
### genomic_annotations argument.
### The naming the genomic_annotations vector allows to name the elements of the list of
### GRanges objects and therefore the features that will be considered in the model.
### Optionnally:
### - In order to calculate the distance of the PWM matches to the closest TSS
### (closest TTS), specify through the tss (tts) argument the path to
### a BED file encoding for each protein-coding transcript the position of its
### TSS (TTS) in the 3 first fiels, its name in the 4th fiels, a "." in the 5th field
### and its orientation ("+" or "-") on the 6th field.
### - In order that the overlap of the PWM matches on gene's regions is only related
### to the gene whose the TSS is the closest, set the path of a BED file encoding the
### regions corresponding to coding sequences (introns/5'UTRs/3'UTRs) through
### the cds (intron/x5utr/x3utr) argument. Proximal promoters, promoters and downstream
### regions are automatically defined based on the specified distances upstream to TSS
### (set through proximalPromoterLength and promoterLength) and the specified distance
### downstream to TTS (set through downstreamLength)
#========================================================================================#
inputSource <- function(genomic_annotations, tss = NULL, tts = NULL,
                        promoterLength = NULL, proximalPromoterLength = NULL, downstreamLength = NULL,
                        cds = NULL, intron = NULL, x5utr = NULL, x3utr =NULL){
  gene_regions <- c(promoterLength, proximalPromoterLength, downstreamLength,
                    cds, intron, x5utr, x3utr)
  if (length(gene_regions) < 7 & length(gene_regions) > 0){
    stop("\nPlease specify all of the following arguments:\n-> tss, tts, promoterLength, proximalPromoterLength, downstreamLength, CDS, intron, x5utr, x3utr ")
  }
  if (length(gene_regions) > 0){
    genomic_annotations <- c(genomic_annotations, gene_regions[4:7])
    names(genomic_annotations)[(length(genomic_annotations)-3):length(genomic_annotations)] <- c("CDS", "Intron", "X5UTR", "X3UTR")
  }
  Annotations_list <- importFeatures(genomic_annotations)
  if (!(is.null(names(genomic_annotations)))){
    names(Annotations_list) <- names(genomic_annotations)
  } else {
  }
  if (length(tss) > 0){
    Annotations_list[["ClosestTSS"]] <- rtracklayer::import(tss)
  }
  if (length(tts) > 0){
    Annotations_list[["ClosestTTS"]] <- rtracklayer::import(tts)
  }
  if (length(gene_regions) > 0 ){
    promoter <- Annotations_list$ClosestTSS
    GenomicRanges::start(promoter[GenomicRanges::strand(promoter) == "+"]) <-
      GenomicRanges::start(promoter[GenomicRanges::strand(promoter) == "+"]) - abs(promoterLength)
    GenomicRanges::end(promoter[GenomicRanges::strand(promoter) == "-"]) <-
      GenomicRanges::end(promoter[GenomicRanges::strand(promoter) == "-"]) + abs(promoterLength)
    proximal_promoter <- Annotations_list$ClosestTSS
    GenomicRanges::start(proximal_promoter[GenomicRanges::strand(proximal_promoter) == "+"]) <-
      GenomicRanges::start(proximal_promoter[GenomicRanges::strand(proximal_promoter) == "+"]) - abs(proximalPromoterLength)
    GenomicRanges::end(proximal_promoter[GenomicRanges::strand(proximal_promoter) == "-"]) <-
      GenomicRanges::end(proximal_promoter[GenomicRanges::strand(proximal_promoter) == "-"]) + abs(proximalPromoterLength)
    downstream <- Annotations_list$ClosestTTS
    GenomicRanges::end(downstream[GenomicRanges::strand(downstream) == "+"]) <-
      GenomicRanges::end(downstream[GenomicRanges::strand(downstream) == "+"]) + abs(downstreamLength)
    GenomicRanges::start(downstream[GenomicRanges::strand(downstream) == "-"]) <-
      GenomicRanges::start(downstream[GenomicRanges::strand(downstream) == "-"]) - abs(downstreamLength)

    Annotations_list <- c(Annotations_list,
                          promoter, proximal_promoter, downstream)
    names(Annotations_list)[(length(Annotations_list)-2):length(Annotations_list)] <-
      c("Promoter", "ProximalPromoter", "Downstream")
  }
  return(Annotations_list)
}
#________________________________________________________________________________________#
#Exported function
#========================================================================================#
### Performs a genome-scale pattern-matching analysis that locate PWM matches that are
### bound and not bound by their TF.
### Outputs a list of GRanges objects. Each GRanges object is related to one of the
### considered TFs and reports location of the PWM matches. The first metadata
### column of the GRanges objects states the log10 p-value of the pattern-matching scores
### of the PWM matches (estimated empirically from the distribution of the raw scores)
### while the second metadata columns states whether a PWM match is bound (=1) or not (=0)
### by its TF.
### The motifs recognized by the considered TFs are input through the pfms argument,
### that sets the path to a file encoding position frequency matrices in the the pfm format,
### as defined by the Jaspar database (http://jaspar.genereg.net). The motifs have to
### be named according to the TFs that bind them, consistently with the names of the
### ChIPpeaks argument (see below)
### The genome sequence is input by specifying the path to a fasta file through the genome
### argument.
### Only PWM matches whose the p-value of the pattern-matching score is below a threshold
### are reported.
### The regions bound by the considered TFs (according to ChIP-seq data) are input by
### setting the paths to BED files through the ChIPpeak argument. Each BED file is related
### to one TF. The ChIPpeaks vector has to be named according to the names of the
### considered TFs. These names have to match with the ones encoded in the pfms file.
### The width of the TFs-bound regions is resized around their centers at a limited width
### set by the ChIPpeaks_width argument, as the TFs binding sites tend to distribute
### around the centers of the ChIP-peaks regions.
### The pattern-matching analysis can be limited to zones that are not too far away from
### gene bodies: located at less than a certain distance upstram to the closest TSS (set
### through maxDistToTSS) and than a certain distance downstream from the closest TTS
### (set through DistToTTS). To do so it is necessary as well to specify through the tss
### (tts) argument the path to a BED file encoding for each protein-coding transcript the
###  position of its TSS (TTS) in the 3 first fiels, its name in the 4th fiels, a "."
###  in the 5th field and its orientation ("+" or "-") on the 6th field.
#========================================================================================#
getPWMmatches <- function(pfms, TFnames = NULL, genome, GRanges = NULL, pvalThreshold = 0.001, ChIPpeaks = NULL, ChIPpeaks_width = 400,
                          tss = NULL, tts = NULL, maxDistToTSS = NULL, maxDistToTTS = NULL){
  genome <- Biostrings::readDNAStringSet(genome)
  names(genome) <- getRiddChr(names(genome))
  if (length(ChIPpeaks) > 0){
    ChIP_regions <- listChIPRegions(ChIPpeaks, ChIPpeaks_width)
    TFnames <- names(ChIP_regions)
    }
  Pwm <- getPwm(pfms, TFnames, genome)
  #Mask regions far away from gene bodies
  mask_parameters <- c(tss, tts, maxDistToTSS, maxDistToTTS)
  if (length(mask_parameters) > 0 & length(mask_parameters) < 4){
    stop("\nPlease specify all of the following arguments:\n-> tss, tts, maxDistToTSS, maxDistToTTS")
  }
  if (length(mask_parameters) > 0){
    TSSTrack <- as.data.frame(rtracklayer::import(tss))
    TTSTrack <- as.data.frame(rtracklayer::import(tts))
    TSSTrack <- TSSTrack[TSSTrack$name %in% TTSTrack$name,]
    TTSTrack <- TTSTrack[TTSTrack$name %in% TSSTrack$name,]
    TSSTrack <- TTSTrack[!(duplicated(TSSTrack$name)),]
    rownames(TSSTrack) <- TSSTrack$name
    TSSTrack <- TSSTrack[TTSTrack$name,]
    TSSTrack$end <- TTSTrack$start
    DirectStranded <- TSSTrack[TSSTrack$strand == "+",]
    DirectStranded <- data.frame(seqnames = DirectStranded$seqnames,
                                 start = DirectStranded$start - abs(maxDistToTSS),
                                 end = DirectStranded$end + abs(maxDistToTTS),
                                 strand = "+")
    ReverseStranded <- TSSTrack[TSSTrack$strand == "-",]
    ReverseStranded <- data.frame(seqnames = ReverseStranded$seqnames,
                                  start = ReverseStranded$end - abs(maxDistToTTS),
                                  end = ReverseStranded$start + abs(maxDistToTSS),
                                  strand = "-")
    DRStranded <- rbind(DirectStranded,
                        ReverseStranded)
    rm(DirectStranded)
    rm(ReverseStranded)

    DRStranded <- DRStranded[DRStranded$seqnames %in% names(genome),]
    DRStranded <- split(DRStranded, f = DRStranded$seqnames)
    DRStranded <- lapply(DRStranded,
                         function(chrdata){
                           chrdata <- chrdata[which((chrdata$end < Biostrings::width(genome)[which(names(genome) == chrdata[1,1])]) & (chrdata$start > 0)),]
                           return(chrdata)
                         })
    DRStranded <- do.call(rbind, DRStranded)
    DRStranded <- GenomicRanges::makeGRangesFromDataFrame(DRStranded,
                                                          keep.extra.columns = TRUE)
    DRStranded <- GenomicRanges::reduce(DRStranded, ignore.strand = TRUE)
  }
  message("Pattern-matching...")
  Matches <-
      lapply(Pwm, matrixScan, genome, 2.5*pvalThreshold, GRanges)
  Matches <- lapply(Matches, function(x) {x <- x[GenomicRanges::mcols(x)[,2] <= log10(pvalThreshold)];
                                          if (length(GenomicRanges::mcols(x)$region) > 0) {columns <- c(matchLogPval = 2, region = 3)} else {columns <- c(matchLogPval = 2)};
                                          GenomicRanges::mcols(x) <- GenomicRanges::mcols(x)[,columns];
                                          names(GenomicRanges::mcols(x)) <- names(columns); return(x)})
  for (i in seq_along(Matches)) {
    GenomeInfoDb::seqlevels(Matches[[i]]) <-
      wimtrap:::getRiddChr(GenomeInfoDb::seqlevels(Matches[[i]]))
  }
  if (length(ChIPpeaks) > 0){
    for (TF in names(Matches)){
      ChIP_data <- ChIP_regions[[TF]]
      GenomicRanges::mcols(Matches[[TF]])[, "ChIP.peak"] <- 0
      true_matches <- GenomicRanges::findOverlaps(Matches[[TF]],
                                                  ChIP_data)
      true_matches <- true_matches@from
      true_matches <- true_matches[!duplicated(true_matches)]
      Matches[[TF]]$ChIP.peak[true_matches] <- 1
    }
  }
  return(Matches)
}

contextualizePWMmatches <- function(PWMmatches, sourceAnnotations, shortWindowLength = 20,
                                    mediumWindowLength = 400, longWindowLength = 1000){
  GeneRegions <- sourceAnnotations[c("Promoter", "ProximalPromoter", "X5UTR",
                                     "CDS", "Intron", "X3UTR", "Downstream",
                                     "ClosestTSS", "ClosestTTS")]
  check <- unlist(lapply(GeneRegions, length))
  #@ If all the necessary information is provided, the position on
  #@ gene's regions will be related only to the protein-coding
  #@ transcript whose gene is the closest
  if (all(check != 0)){
  sourceAnnotations <- sourceAnnotations[!(names(sourceAnnotations) %in% names(GeneRegions)[1:(length(GeneRegions)-2)])]
  }
  AnnotatedScanResults <- list()
  for (i in seq_along(PWMmatches)) {
    print(paste("=>", names(PWMmatches)[i]))
    if (length(PWMmatches[[i]]) > 0){
      #@ Make the location of the matches as source annotations
      MatchFeature <- as.data.frame(PWMmatches[[i]])
      MatchFeature$strand <- "*"
      MatchFeature <- GenomicRanges::makeGRangesFromDataFrame(MatchFeature)
      sourceAnnotations[["Matches"]] <- MatchFeature
      #@ Considered a balanced data set of TF-bound and TF-not bound
      #@ PWM matches
      if (length(PWMmatches[[i]]$ChIP.peak) > 0){
        true_matches <- PWMmatches[[i]][which(PWMmatches[[i]]$ChIP.peak == 1)]
        indices_false_matches <- which(PWMmatches[[i]]$ChIP.peak == 0)
        false_matches <- indices_false_matches[sample(length(indices_false_matches),
                                                      length(true_matches))]
        false_matches <- PWMmatches[[i]][false_matches]
        balanced_matches <- c(true_matches, false_matches)
        balanced_matches <- GenomicRanges::sort.GenomicRanges(balanced_matches)
        PWMmatches[[i]] <- balanced_matches
      }
      AnnotatedMatches <- PWMmatches[[i]]
      if (all(check) != 0){
        if (length(GenomicRanges::mcols(AnnotatedMatches)$region) > 0){
          region <- GenomicRanges::mcols(AnnotatedMatches)$region
          GenomicRanges::mcols(AnnotatedMatches) <- GenomicRanges::mcols(AnnotatedMatches)[,-2]
          colnames(GenomicRanges::mcols(AnnotatedMatches)) <- "matchLogPval"
        }
      #@ Annotations with the gene's regions
       for (structure in names(GeneRegions)[1:(length(GeneRegions)-2)]){
          GenomicRanges::mcols(AnnotatedMatches)[structure] <- 0
          GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::findOverlaps(PWMmatches[[i]], GeneRegions[[structure]])@from,structure] <- 1
        }
        AnnotatedMatches <- getClosest(AnnotatedMatches, GeneRegions[c("ClosestTTS", "ClosestTSS")], modeling = FALSE, TSS = FALSE)
        AnnotatedMatches <- getClosest(AnnotatedMatches, GeneRegions[c("ClosestTTS", "ClosestTSS")], modeling = FALSE, TSS = TRUE)
        ClosestTTS.dataframe <- as.data.frame(GeneRegions$ClosestTTS)
        ClosestTTS.dataframe <- ClosestTTS.dataframe[!duplicated(ClosestTTS.dataframe$name),]
        rownames(ClosestTTS.dataframe) <- ClosestTTS.dataframe$name
        DistanceToTTS <- (GenomicRanges::start(AnnotatedMatches)+((GenomicRanges::end(AnnotatedMatches)-GenomicRanges::start(AnnotatedMatches))/2)) -
          ClosestTTS.dataframe[as.character(GenomicRanges::mcols(AnnotatedMatches)$ClosestTSS), "start"]
        if (length(DistanceToTTS[ClosestTTS.dataframe[as.character(GenomicRanges::mcols(AnnotatedMatches)$ClosestTSS), "strand"] == "-"]) > 0){
          DistanceToTTS[ClosestTTS.dataframe[as.character(GenomicRanges::mcols(AnnotatedMatches)$ClosestTSS), "strand"] == "-"] <- -DistanceToTTS[ClosestTTS.dataframe[as.character(GenomicRanges::mcols(AnnotatedMatches)$ClosestTSS), "strand"] == "-"]
        }
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$DistToClosestTSS > 0,"Promoter"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$DistToClosestTSS > 0,"ProximalPromoter"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$ProximalPromoter == 1,"Promoter"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[DistanceToTTS < 0,"Downstream"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$CDS == 1,"X5UTR"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$CDS == 1,"X3UTR"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$CDS == 1,"Intron"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$Intron == 1,"X5UTR"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$Intron == 1,"X3UTR"] <- 0
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::mcols(AnnotatedMatches)$X5UTR == 1,"X3UTR"] <- 0
      } else {
        if (length(GeneRegions[c("ClosestTSS", "ClosestTTS")]) == 2){
          AnnotatedMatches <- getClosest(AnnotatedMatches, GeneRegions[c("ClosestTSS", "ClosestTTS")], modeling = FALSE, TSS = FALSE)
          AnnotatedMatches <- getClosest(AnnotatedMatches, GeneRegions[c("ClosestTSS", "ClosestTTS")], modeling = FALSE, TSS = TRUE)

        }
      }

      #@ Annotations with the categorical features
      categorical <- c()
      for (feature in names(sourceAnnotations)){
        if (length(sourceAnnotations[[feature]]@elementMetadata@listData) > 0){
          if(is.factor(sourceAnnotations[[feature]]@elementMetadata@listData[[1]])){
            categorical <- c(categorical, feature)
          }
        }
      }

      for (categoricalfeature in categorical){
        GenomicRanges::mcols(AnnotatedMatches)[categoricalfeature] <- "NA"
        GenomicRanges::mcols(AnnotatedMatches)[GenomicRanges::findOverlaps(PWMmatches[[i]], sourceAnnotations[[categoricalfeature]])@from,
                                               categoricalfeature] <- as.character(GenomicRanges::mcols(sourceAnnotations[[categoricalfeature]])[GenomicRanges::findOverlaps(PWMmatches[[i]], sourceAnnotations[[categoricalfeature]])@to,1])
      }

      #@ Annotations with the overlapping and numeric features
      #@ considering different windows
      for (feature in names(sourceAnnotations)){
        if (length(sourceAnnotations[[feature]]@elementMetadata@listData) == 0){
          GenomicRanges::mcols(sourceAnnotations[[feature]])[feature] <- 1
        }
      }

      for (windowlength in c(shortWindowLength, mediumWindowLength, longWindowLength)){
        queries <- GenomicRanges::resize(AnnotatedMatches, windowlength, fix = "center")
        for (feature in names(sourceAnnotations)[!(names(sourceAnnotations) %in% c(categorical,"ClosestTSS", "ClosestTTS"))]){
          overlaps <- GenomicRanges::findOverlaps(queries, sourceAnnotations[[feature]])
          peakcuts <- data.frame(start.query = GenomicRanges::start(queries[overlaps@from]),
                                 end.query = GenomicRanges::end(queries[overlaps@from]),
                                 start.subject = GenomicRanges::start(sourceAnnotations[[feature]][overlaps@to]),
                                 end.subject = GenomicRanges::end(sourceAnnotations[[feature]][overlaps@to]))
          peakcuts$start.subject[peakcuts$start.subject < peakcuts$start.query] <- peakcuts$start.query[peakcuts$start.subject < peakcuts$start.query]
          peakcuts$end.subject[peakcuts$end.subject > peakcuts$end.query] <- peakcuts$end.query[peakcuts$end.subject > peakcuts$end.query]
          peakcuts$contribution <- (GenomicRanges::mcols(sourceAnnotations[[feature]])[overlaps@to,1]*(peakcuts$end.subject-peakcuts$start.subject+1))/windowlength
          GenomicRanges::mcols(AnnotatedMatches)[paste0(c(feature, "_", windowlength, "bp"), collapse = "")] <- 0
          GenomicRanges::mcols(AnnotatedMatches)[overlaps@from[!duplicated(overlaps@from)], length(GenomicRanges::mcols(AnnotatedMatches))] <- tapply(peakcuts$contribution, overlaps@from, sum)
        }
      }

      # Calculate the number of PWM matches in the 100bp and 400bp windows centered
      # on the considered PWM matches
      GenomicRanges::mcols(AnnotatedMatches)[paste0("Matches_", mediumWindowLength, "bp")] <- (GenomicRanges::mcols(AnnotatedMatches)[paste0("Matches_", mediumWindowLength, "bp")][,1]*mediumWindowLength)/GenomicRanges::width(AnnotatedMatches[1])
      GenomicRanges::mcols(AnnotatedMatches)[paste0("Matches_", longWindowLength, "bp")] <- (GenomicRanges::mcols(AnnotatedMatches)[paste0("Matches_", longWindowLength, "bp")][,1]*longWindowLength)/GenomicRanges::width(AnnotatedMatches[1])
      AnnotatedMatches <- as.data.frame(AnnotatedMatches)
      AnnotatedMatches$TF <- names(PWMmatches)[i]
      if (length(region) > 0){
        AnnotatedMatches$region <- region
      }
      AnnotatedScanResults[[names(PWMmatches)[i]]] <- AnnotatedMatches
      }
  }
  DataSet <- do.call(rbind, AnnotatedScanResults)
  DataSet <- data.table::as.data.table(DataSet)
  DataSet <- DataSet[, -c("Matches_20bp"), with = FALSE]
  return(DataSet)
}
#________________________________________________________________________________________#
#HIDDEN FUNCTION
#========================================================================================#
### Train by extreme gradient boosting a model of classification of PWM matches between
### true and false binding sites based on pattern-matching analysis results and contextual
### genomic features.
#========================================================================================#
xgbmodeling <- function(data, TFspecific, TF4Validation){
  data <- data[,-seq(1,6), with = FALSE]
  #Put asides TF(s) that will be used for external validation
  if (length(TF4Validation) > 0){
    data <- data[!(data$TF %in% TF4Validation)]
  } else {}
  #Remove columns that do not have to be taken into account
  if (!TFspecific){
    if (length(grep(pattern = "TF", colnames(data))) > 0){
      torm <- grep(pattern = "TF", colnames(data))
      data <- data[, colnames(data)[torm] := NULL]
    } else {}
  } else {}
  if (length(grep(pattern = "ClosestTSS", colnames(data))) > 0){
    torm <- grep(pattern = "ClosestTSS", colnames(data))
    data <- data[, colnames(data)[torm] := NULL]
  } else {}
  if (length(grep(pattern = "ClosestTTS", colnames(data))) > 0){
    torm <- grep(pattern = "ClosestTTS", colnames(data))
    data <- data[, colnames(data)[torm] := NULL]
  } else {}
  # Remove the infinite p-values associated to P-M,
  # that occurs when the PWM is not flexible (i.e. is a consensus)
  data$matchLogPval[which(is.infinite(data$matchLogPval))] <- -3
  #Create dummy variables
  dummy <- model.matrix(~.+0, data = data[,-c("ChIP.peak"),with=F])
  data <- cbind(dummy, data[,"ChIP.peak"])
  #Remove highly correlated features
  descrCor <- cor(data, use = 'complete')
  highlyCorDescr <- caret::findCorrelation(descrCor, cutoff = .95)
  filteredDescr <- data[,colnames(data)[highlyCorDescr] := NULL]
  NAs <- is.na(as.data.frame(filteredDescr))
  NAs <- apply(NAs, 1, function(x) {if (length(which(x==TRUE)) > 0 ) {return(TRUE)} else {return(FALSE)} })
  filteredDescr <- filteredDescr[!NAs,]

  #Build a model by extreme gradient boosting
  trainind <- sample(seq(1,nrow(filteredDescr)), nrow(filteredDescr)/2)
  testind <- seq(1,nrow(filteredDescr))[seq(1,nrow(filteredDescr)) != trainind]

  train <- filteredDescr[trainind,]
  test <- filteredDescr[testind,]

  labels <- train$ChIP.peak
  ts_label <- test$ChIP.peak

  new_tr <- model.matrix(~.+0,data = train[,-c("ChIP.peak"),with=F])
  new_ts <- model.matrix(~.+0,data = test[,-c("ChIP.peak"),with=F])

  dtrain <- xgboost::xgb.DMatrix(data = new_tr,label = labels)
  dtest <- xgboost::xgb.DMatrix(data = new_ts,label=ts_label)

  params <- list(booster = "gbtree", objective = "binary:logistic", eta=0.3, gamma=0, max_depth=6, min_child_weight=1, subsample=1, colsample_bytree=1)
  xgbcv <- xgboost::xgb.cv( params = params, data = dtrain, nrounds = 100, nfold = 5, showsd = T, stratified = T, print.every.n = 10, early.stop.round = 20, maximize = F)

  xgb1 <- xgboost::xgb.train(params = params, data = dtrain, nrounds = xgbcv$best_iteration, watchlist = list(val=dtest,train=dtrain), print.every.n = 10, early.stop.round = 10, maximize = F , eval_metric = "error")
  xgbpred <- predict(xgb1,dtest)

  results <- list(model = xgb1,
                  validation = xgbpred,
                  response = ts_label,
                  pm = test$matchLogPval)
  return(results)
}

wimtrapredict <- function(contextualized_TFBScandidates, ModelTFBS){
  TF <- contextualized_TFBScandidates[,"TF"]
  region <- contextualized_TFBScandidates[,"region"]
  ranges <- contextualized_TFBScandidates[,seq(1,5), with = FALSE]
  contextualized_TFBScandidates <- contextualized_TFBScandidates[,-"region"]
  contextualized_TFBScandidates <- contextualized_TFBScandidates[,-seq(1,5), with = FALSE]
  if (length(grep(pattern = "ClosestTSS", colnames(contextualized_TFBScandidates))) > 0){
    torm <- grep(pattern = "ClosestTSS", colnames(contextualized_TFBScandidates))
    contextualized_TFBScandidates <- contextualized_TFBScandidates[, colnames(contextualized_TFBScandidates)[torm] := NULL]
  } else {}
  if (length(grep(pattern = "ClosestTTS", colnames(contextualized_TFBScandidates))) > 0){
    torm <- grep(pattern = "ClosestTTS", colnames(contextualized_TFBScandidates))
    contextualized_TFBScandidates <- contextualized_TFBScandidates[, colnames(contextualized_TFBScandidates)[torm] := NULL]
  } else {}
  if (length(grep(pattern = "region", colnames(contextualized_TFBScandidates))) > 0){
    torm <- grep(pattern = "region", colnames(contextualized_TFBScandidates))
    contextualized_TFBScandidates <- contextualized_TFBScandidates[, colnames(contextualized_TFBScandidates)[torm] := NULL]
  } else {}
  # Remove the infinite p-values associated to P-M,
  # that occurs when the PWM is not flexible (i.e. is a consensus)
  if (length(which(is.infinite(contextualized_TFBScandidates$matchLogPval))) > 0){
  contextualized_TFBScandidates$matchLogPval[which(is.infinite(contextualized_TFBScandidates$matchLogPval))] <- -3
  }
  #Create dummy variables
  contextualized_TFBScandidates <- model.matrix(~.+0, data = contextualized_TFBScandidates)
  contextualized_TFBScandidates <- contextualized_TFBScandidates[,colnames(contextualized_TFBScandidates) %in% (ModelTFBS$feature_names)]
  contextualized_TFBScandidates <- contextualized_TFBScandidates[,ModelTFBS$feature_names]
  #Predicted as true with a score > 0.5
  xgbpred <- predict(ModelTFBS, contextualized_TFBScandidates)
  result <- GenomicRanges::makeGRangesFromDataFrame(
    data.frame(
      ranges,
      region = region,
      score = round(xgbpred, 3),
      TF = TF
    ),
    keep.extra.columns = TRUE
  )
  return(result)
}

plotPredictions <- function(TFBSpredictions, gene, TFs, contextual_features = NULL, sourceAnnotations = NULL, geneModels){
  structures <- data.table::fread(geneModels)
  transcripts <- structures$`Transcript stable ID`[grep(pattern = gene, structures$`Transcript stable ID`)]
  transcripts <- transcripts[!duplicated(structures$`Transcript start (bp)`[grep(pattern = gene, structures$`Transcript stable ID`)])]
  models <- lapply(transcripts, function(x, structures){
    considered <- structures[structures$`Transcript stable ID` == x,]
    model <- data.frame(chromosome = considered$`Chromosome/scaffold name`[1],
                        start = c(considered$`5' UTR start`[!is.na(considered$`5' UTR start`)],
                                  considered$`3' UTR start`[!is.na(considered$`3' UTR start`)]),
                        end = c(considered$`5' UTR end`[!is.na(considered$`5' UTR end`)],
                                considered$`3' UTR end`[!is.na(considered$`3' UTR end`)]),
                        width = 0,
                        strand = considered$Strand[1],
                        feature = c(rep("utr5", length(considered$`5' UTR start`[!is.na(considered$`5' UTR start`)])),
                                    rep("utr3", length(considered$`3' UTR start`[!is.na(considered$`3' UTR start`)]))),
                        gene = gene,
                        exon = x,
                        transcript = x,
                        symbol = gene)
    utrs <- c(which(!is.na(considered$`5' UTR start`)), which(!is.na(considered$`3' UTR start`)))
    widths_utrs <- model$end-model$start
    widths_exons <- considered$`Exon region end (bp)`[utrs]-considered$`Exon region start (bp)`[utrs]
    complete <- which((widths_exons-widths_utrs)==0)
    partial <- which((widths_exons-widths_utrs)!=0)
    if (length(partial) > 0){
      for (exon in partial){
        exon_considered <- considered[utrs[exon],]
        if (!is.na(exon_considered$`5' UTR start`)){
          if (considered$Strand[1] == 1){
            exon_considered$`Exon region start (bp)` <- (exon_considered$`5' UTR end`+1)
          } else {
            exon_considered$`Exon region end (bp)` <- (exon_considered$`5' UTR start`-1)
          }
        } else {
          if (considered$Strand[1] == 1){
            exon_considered$`Exon region end (bp)` <- (exon_considered$`3' UTR start`-1)
          } else {
            exon_considered$`Exon region start (bp)` <- (exon_considered$`3' UTR end`+1)
          }
        }
        considered[utrs[exon],] <- exon_considered
      }
    }
    if (length(complete) > 0){
      considered <- considered[,-utrs[complete], with = FALSE]
    }
    model <- rbind(model,
                   data.frame(chromosome = considered$`Chromosome/scaffold name`,
                              start = considered$`Exon region start (bp)`,
                              end = considered$`Exon region end (bp)`,
                              width = 0,
                              strand = considered$Strand,
                              feature = "exon",
                              gene = gene,
                              exon = x,
                              transcript = x,
                              symbol = gene)
                   )
    model$width <- (model$end-model$start)+1
    return(model)
  }, structures)
  models <- do.call(rbind, models)
  grtrack <- Gviz::GeneRegionTrack(models, name="Gene Model", transcriptAnnotation="symbol", background.title="brown")
  gtrack <- Gviz::GenomeAxisTrack()
  strack <- list()
  col <- grDevices::rainbow(length(levels(as.factor(GenomicRanges::mcols(TFBSpredictions)$TF))))
  names(col) <- levels(as.factor(GenomicRanges::mcols(TFBSpredictions)$TF))
  GenomicRanges::strand(TFBSpredictions) <- "*"
  TFBSpredictions <- TFBSpredictions[which(GenomicRanges::mcols(TFBSpredictions)$TF %in% TFs)]
  strack <- list()
  for (TF in levels(as.factor(GenomicRanges::mcols(TFBSpredictions)$TF))){
    strack[[TF]] <- Gviz::DataTrack(TFBSpredictions[GenomicRanges::mcols(TFBSpredictions)$TF == TF],
                                 name = TF, col = col[TF], background.title = col[TF])
  }
  if (length(contextual_features) > 0){
    col <- grDevices::topo.colors(length(contextual_features))
    names(col) <- contextual_features
    ctrack <- list()
    for (feature in contextual_features){
      extracted <- sourceAnnotations[[feature]][GenomicRanges::seqnames(sourceAnnotations[[feature]])
                                                == as.character(models$chromosome[1])]
      extracted <- GenomeInfoDb::keepSeqlevels(extracted,
                                               as.character(models$chromosome[1]))
      overlapping <- GenomicRanges::findOverlaps(extracted, GenomicRanges::makeGRangesFromDataFrame(data.frame(seqname = as.character(models$chromosome[1]),
                                                                                                    start = min(models$start)+2000,
                                                                                                    end = max(models$end)+2000,
                                                                                                    strand = "*")))
      extracted <- extracted[overlapping@from[!duplicated(overlapping@from)]]
      if (length(extracted) > 0){
      extracted <-GenomicRanges::sort(extracted)
      complements <- extracted[-length(extracted)]
      GenomicRanges::mcols(complements)[,1] <- 0
      for (i in seq_along(complements)){
        GenomicRanges::start(complements[i]) <- GenomicRanges::end(complements[i])
        GenomicRanges::end(complements[i]) <- GenomicRanges::start(extracted[i+1])
      }
      complements <- c(extracted[1], complements)
      GenomicRanges::end(complements)[1] <- GenomicRanges::start(complements)[1]
      GenomicRanges::start(complements)[1] <- min(models$start)-2000
      complements <- c(complements, extracted[length(complements)])
      GenomicRanges::start(complements)[length(complements)] <- GenomicRanges::end(complements[length(complements)])
      GenomicRanges::end(complements[length(complements)]) <- max(models$end)+2000
      GenomicRanges::mcols(complements)[,1] <- 0
      extracted <- c(extracted, complements)
      extracted <- GenomicRanges::sort(extracted)
      tmp_extracted <- extracted
      GenomicRanges::end(tmp_extracted) <- GenomicRanges::start(tmp_extracted)
      GenomicRanges::start(extracted) <- GenomicRanges::end(extracted)
      extracted <- c(extracted, tmp_extracted)
      extracted <- GenomicRanges::sort(extracted)
      ctrack[[feature]] <- Gviz::DataTrack(extracted, col = col[feature], name = feature)
      } else {
        extracted <- GenomicRanges::makeGRangesFromDataFrame(
          data.frame(seqname = models$chromosome[1],
                     start = c(min(models$start)-2000, max(models$end)+2000),
                     end = c(min(models$start)-2000, max(models$end)+2000),
                     feature = 0
        ), keep.extra.columns = TRUE)
        ctrack[[feature]] <- Gviz::DataTrack(extracted, col = col[feature], name = feature)
      }
    }
    ncols <- 1
    nrows <- 2
    grid.newpage()
    pushViewport(viewport(layout=grid.layout(nrows, ncols)))
    grid::pushViewport(grid::viewport(layout.pos.col=((1-1)%%ncols)+1, layout.pos.row=(((1)-1)%/%ncols)+1))
    Gviz::plotTracks(c(list(gtrack, grtrack), strack), from = min(models$start)-2000, to = max(models$end)+2000, type = "p", add=TRUE)
    grid::popViewport(1)
    grid::pushViewport(grid::viewport(layout.pos.col=1, layout.pos.row=2))
    Gviz::plotTracks(ctrack, from = min(models$start)-2000, to = max(models$end)+2000, type = "s", add=TRUE)
    grid::popViewport(1)



  } else {
    Gviz::plotTracks(c(list(gtrack, grtrack), strack), from = min(models$start)-2000, to = max(models$end)+2000, type ="p")
  }
}
